
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">auth/pkg/authcode/authcode.go (100.0%)</option>
				
				<option value="file1">auth/pkg/authjwt/authjwt.go (100.0%)</option>
				
				<option value="file2">auth/pkg/authmail/authmail.go (100.0%)</option>
				
				<option value="file3">auth/pkg/database/access.go (80.9%)</option>
				
				<option value="file4">auth/pkg/database/database.go (79.1%)</option>
				
				<option value="file5">auth/pkg/database/hashing.go (78.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package authcode

import (
        "math/rand"
        "time"
)

type authorizationCode struct {
        ForUser string
        Code    string
        Created time.Time
        Expires time.Time
}

var activeCodes map[string]*authorizationCode = make(map[string]*authorizationCode)

var letters = []rune("ABCDEFGHIJKLMNOPQRSTUVWXYZ")

func genCode(ct int) string <span class="cov8" title="1">{
        seq := make([]rune, ct)
        for i := range seq </span><span class="cov8" title="1">{
                seq[i] = letters[rand.Intn(len(letters))]
        }</span>
        <span class="cov8" title="1">return string(seq)</span>
}

// Create a new authorization code for a given user
func NewAuthCode(forUser string) *authorizationCode <span class="cov8" title="1">{
        now := time.Now()
        newCode := &amp;authorizationCode{
                ForUser: forUser,
                Code:    genCode(6),
                Created: now,
                Expires: now.Add(time.Minute),
        }
        activeCodes[forUser] = newCode
        return newCode
}</span>

// Validate an authorization code
func ValidateAuthCode(forUser, code string) bool <span class="cov8" title="1">{
        storedCode, ok := activeCodes[forUser]
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if storedCode.Code == code &amp;&amp; storedCode.Expires.After(time.Now()) </span><span class="cov8" title="1">{
                delete(activeCodes, forUser)
                return true
        }</span> else<span class="cov8" title="1"> {
                delete(activeCodes, forUser)
                return false
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package authjwt

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "strings"
        "time"
)

// JWTHeader: `auth` treats these as constants.
type JWTHeader struct {
        Algorithm string `json:"alg"`
        Type      string `json:"typ"`
}

// JWTBody: Token claims. All are registered except access, which is private.
type JWTBody struct {
        Issuer  string                 `json:"iss"`
        ForUser string                 `json:"sub"`
        Access  map[string]interface{} `json:"access"`
        Created int64                  `json:"iat"`
        Expires int64                  `json:"exp"`
}

// JSON Web Token structure combining the above.
type JSONWebToken struct {
        Header JWTHeader
        Body   JWTBody
}

// Create a new JWT based on a user email and access tag
func NewJWT(user string, access map[string]interface{}) *JSONWebToken <span class="cov8" title="1">{
        return &amp;JSONWebToken{
                JWTHeader{
                        Algorithm: "sha256",
                        Type:      "jwt",
                },
                JWTBody{
                        Issuer:  "auth",
                        ForUser: user,
                        Access:  access,
                        Created: time.Now().Unix(),
                        Expires: time.Now().Add(1 * time.Hour).Unix(),
                },
        }
}</span>

// Export a JSONWebToken using a given secret
func Export(t *JSONWebToken, secret []byte) (string, error) <span class="cov8" title="1">{
        h := hmac.New(sha256.New, secret)
        // Marshal and encode the JWT header/body separately
        head, _ := json.Marshal(t.Header)
        headStr := base64.RawURLEncoding.EncodeToString(head)
        body, err := json.Marshal(t.Body)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">bodyStr := base64.RawURLEncoding.EncodeToString(body)
        // Write head.body to the hashing algorithm
        h.Write([]byte(
                headStr + "." + bodyStr,
        ))
        // Get the signature from the hash
        signature := base64.RawURLEncoding.EncodeToString(h.Sum(nil))
        // Concatenate head.body.signature
        return headStr + "." + bodyStr + "." + signature, nil</span>
}

// Verify that a token string is unaltered, unexpired, and signed with the given secret
func Verify(token string, secret []byte) (*JSONWebToken, bool, error) <span class="cov8" title="1">{
        items := strings.Split(token, ".")
        // Unmarshal and decode the JWT
        jwt := &amp;JSONWebToken{}
        head, err := base64.RawURLEncoding.DecodeString(items[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal([]byte(head), &amp;(jwt.Header))
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">body, err := base64.RawURLEncoding.DecodeString(items[1])
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal([]byte(body), &amp;(jwt.Body))
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>
        // Re-export the resulting jwt; should result in the exact same output
        <span class="cov8" title="1">expected, _ := Export(jwt, secret)
        // Return verification eval result and new token
        expired := jwt.Body.Expires &lt; time.Now().Unix()
        return jwt, token == expected &amp;&amp; !expired, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package authmail

import (
        "fmt"
        "net/smtp"
)

// struct Host holds host data for sending SMTP through SES.
type Host struct {
        Username string
        Password string
        Host     string
        Port     int
        Sender   string
}

// Generate a PlainAuth to use with smtp.SendMail using host info
func (h Host) plainAuth() smtp.Auth <span class="cov8" title="1">{
        return smtp.PlainAuth("", h.Username, h.Password, h.Host)
}</span>

// Generate an address for smtp.SendMail
func (h Host) address() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%d", h.Host, h.Port)
}</span>

// Generate a new authentication message given a target email and authentication code.
func NewAuthMessage(sendTo string, authCode string) []byte <span class="cov8" title="1">{
        msg := fmt.Sprintf(
                "To: %s\r\n"+
                        "Subject: Authentication Code\r\n"+
                        "\r\n"+
                        "Your authentication code is %s.\n"+
                        "This code will expire in 1 minute.\r\n",
                sendTo, authCode,
        )
        return []byte(msg)
}</span>

// Use smtp to send a message through the target SES host
func SendMessage(sendFrom Host, sendTo string, msg []byte) <span class="cov8" title="1">{
        auth := sendFrom.plainAuth()
        target := []string{sendTo}
        addr := sendFrom.address()
        smtp.SendMail(addr, auth, sendFrom.Sender, target, msg)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package database

import (
        badger "github.com/dgraph-io/badger/v3"
        "github.com/pkg/errors"
)

// Database "generics"; get/set from collection of badger databases

type DatabaseCollection map[string]*badger.DB

// Open a database at /tmp/{name}. if write == false, NO DATA will be written to disk.
// Leave write = true unless you're testing.
func openDatabase(name string, write bool) (*badger.DB, error) <span class="cov8" title="1">{
        if write </span><span class="cov0" title="0">{
                return badger.Open(badger.DefaultOptions("./dat/database/" + name))
        }</span> else<span class="cov8" title="1"> {
                return badger.Open(badger.DefaultOptions("").WithInMemory(true))
        }</span>
}

// Open every DB in a DatabaseCollection. See description for write arg above in openDatabase.
func (coll DatabaseCollection) opened(write bool) (DatabaseCollection, error) <span class="cov8" title="1">{
        var err error
        for name := range coll </span><span class="cov8" title="1">{
                coll[name], err = openDatabase(name, write)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return coll, nil</span>
}

func setKey(db *badger.DB, key, value []byte) error <span class="cov8" title="1">{
        if db == nil </span><span class="cov0" title="0">{
                return errors.New("Attempted to setKey on a nil database")
        }</span>
        <span class="cov8" title="1">if err := db.Update(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                err := txn.Set(key, value)
                if err == badger.ErrConflict </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err == badger.ErrTxnTooBig </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">return nil</span>
        }); err != nil <span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> {
                return nil
        }</span>
}

func getKey(db *badger.DB, key []byte) ([]byte, error) <span class="cov8" title="1">{
        if db == nil </span><span class="cov0" title="0">{
                return nil, errors.New("Attempted to getKey on a nil database")
        }</span>
        <span class="cov8" title="1">var val []byte
        if err := db.View(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                item, err := txn.Get(key)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">item.Value(func(v []byte) error </span><span class="cov8" title="1">{
                        val = v
                        return nil
                }</span>)
                <span class="cov8" title="1">return nil</span>
        }); err != nil <span class="cov8" title="1">{
                return nil, err
        }</span> else<span class="cov8" title="1"> {
                return val, nil
        }</span>
}

func keyExists(db *badger.DB, key []byte) (bool, error) <span class="cov8" title="1">{
        if db == nil </span><span class="cov0" title="0">{
                return false, errors.New("Attempted to getKey on a nil database")
        }</span>
        <span class="cov8" title="1">var val bool = false
        if err := db.View(func(txn *badger.Txn) error </span><span class="cov8" title="1">{
                opts := badger.DefaultIteratorOptions
                opts.PrefetchValues = false
                it := txn.NewIterator(opts)
                defer it.Close()
                for it.Rewind(); it.Valid(); it.Next() </span><span class="cov8" title="1">{
                        if string(it.Item().Key()) == string(key) </span><span class="cov8" title="1">{
                                val = true
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }); err != nil <span class="cov0" title="0">{
                return false, err
        }</span> else<span class="cov8" title="1"> {
                return val, nil
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package database

import (
        "encoding/json"
        "fmt"

        "github.com/pkg/errors"
)

var DATABASE_TESTING bool = true

type UserCred struct {
        Email        string `json:"email"`
        Username     string `json:"username"`
        PasswordHash string `json:"password"`
        PasswordSalt string `json:"salt"`
        HashFunc     string `json:"hf"`
}

type UserPerm map[string]bool

type UserEntry struct {
        Credentials UserCred `json:"credentials"`
        Permissions UserPerm `json:"permissions"`
}

var authDBLayout DatabaseCollection = DatabaseCollection{
        "users": nil,
}

func authDBKey(email, username string) []byte <span class="cov8" title="1">{
        email = stringEncode([]byte(email))
        username = stringEncode([]byte(username))
        return []byte(email + "." + username)
}</span>

func OpenDB() error <span class="cov8" title="1">{
        var err error
        authDBLayout, err = authDBLayout.opened(!DATABASE_TESTING)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func CloseDB() error <span class="cov8" title="1">{
        for _, db := range authDBLayout </span><span class="cov8" title="1">{
                err := db.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func RegisterUser(email, username, password string, permissions UserPerm) error <span class="cov8" title="1">{
        // Check to make sure we're not re-registering a user
        if registered, err := keyExists(authDBLayout["users"], authDBKey(email, username)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span> else<span class="cov8" title="1"> {
                if registered </span><span class="cov8" title="1">{
                        return errors.New("User already registered")
                }</span>
        }
        <span class="cov8" title="1">salt, err := genSalt()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">pwdHash, err := slowHash([]byte(password), salt, "sha512")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">entry := UserEntry{
                Credentials: UserCred{
                        email,
                        username,
                        pwdHash,
                        stringEncode(salt),
                        "sha512",
                },
                Permissions: permissions,
        }
        out, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = setKey(authDBLayout["users"], authDBKey(email, username), out)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func ValidateUserCred(email, username, password string) (bool, error) <span class="cov8" title="1">{
        dbval, err := getKey(authDBLayout["users"], authDBKey(email, username))
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">entry := UserEntry{}
        if err := json.Unmarshal(dbval, &amp;entry); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">salt, _ := stringDecode(entry.Credentials.PasswordSalt)
        pwdHash, err := slowHash([]byte(password), salt, entry.Credentials.HashFunc)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">fmt.Printf("%s:\n%s\n%s\n", username, pwdHash, entry.Credentials.PasswordHash)
        fmt.Printf("%t, %t\n", username == entry.Credentials.Username, pwdHash == entry.Credentials.PasswordHash)
        return username == entry.Credentials.Username &amp;&amp; pwdHash == entry.Credentials.PasswordHash, nil</span>
}

func ChangeUserPassword(email, username, password string, newPassword string) error <span class="cov8" title="1">{
        // Get current user data. This will fail if the user does not exist.
        dbval, err := getKey(authDBLayout["users"], authDBKey(email, username))
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">entry := UserEntry{}
        if err := json.Unmarshal(dbval, &amp;entry); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Need to validate old password to change to a new one.
        <span class="cov8" title="1">if oldOk, _ := ValidateUserCred(email, username, password); !oldOk </span><span class="cov8" title="1">{
                return errors.New("Password change failed: old password incorrect")
        }</span> else <span class="cov8" title="1">{
        }</span>
        // Generate password hash
        <span class="cov8" title="1">salt, err := genSalt()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">pwdHash, err := slowHash([]byte(newPassword), salt, "sha512")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">entry.Credentials.PasswordHash = pwdHash
        entry.Credentials.PasswordSalt = stringEncode(salt)
        // Write out new entry
        out, err := json.Marshal(entry)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = setKey(authDBLayout["users"], authDBKey(email, username), out)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package database

import (
        "crypto/rand"
        "crypto/sha512"
        "encoding/base64"
        "hash"
        "time"

        "github.com/pkg/errors"
)

// stringEncode shorthands for base64.URLEncoding.EncodeToString
func stringEncode(b []byte) string <span class="cov8" title="1">{
        return base64.RawURLEncoding.EncodeToString(b)
}</span>

// stringDecode shorthands base64.URLEncoding.DecodeString
func stringDecode(s string) ([]byte, error) <span class="cov8" title="1">{
        return base64.RawURLEncoding.DecodeString(s)
}</span>

// genSalt returns a 64-bit random byte string
func genSalt() ([]byte, error) <span class="cov8" title="1">{
        salt := make([]byte, 64)
        _, err := rand.Read(salt[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return salt, nil</span>
}

const hashRounds int = 65536
const minHashMS int = 20
const maxHashMS int = 0

var hfs map[string]func() hash.Hash = map[string]func() hash.Hash{
        "sha512": sha512.New,
}

// VERY SLOWLY hash pwd using a named hashFunc supported by auth.database, see hfs above
// Returns hash, salt, error (if occurs)
// DO NOT call any other hash function.
func slowHash(pwd, salt []byte, hashFunc string) (string, error) <span class="cov8" title="1">{
        // Get hash func. Return error if not supported
        f, ok := hfs[hashFunc]
        if !ok </span><span class="cov0" title="0">{
                return "", errors.Errorf("Hash function %s not supported", hashFunc)
        }</span>
        <span class="cov8" title="1">hf := f()
        pwd_full := append(pwd, salt...)
        pwd_hash := make([]byte, base64.URLEncoding.EncodedLen(hf.Size()))
        // Initial hash into pwd_hash
        if _, err := hf.Write(pwd_full); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span> else<span class="cov8" title="1"> {
                pwd_hash = hf.Sum(nil)
        }</span>
        // Repeatedly hash for hashRounds. Track time to complete.
        <span class="cov8" title="1">start := time.Now()
        for i := 0; i &lt; hashRounds; i++ </span><span class="cov8" title="1">{
                if _, err := hf.Write(pwd_hash); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span> else<span class="cov8" title="1"> {
                        pwd_hash = hf.Sum(nil)
                }</span>
        }
        <span class="cov8" title="1">dur := time.Now().Sub(start).Milliseconds()
        if dur &lt; int64(minHashMS) </span><span class="cov0" title="0">{
                return "", errors.Errorf("Hash function with %d rounds took %d ms (min %d). You should increase the number of rounds.", hashRounds, dur, minHashMS)
        }</span>
        <span class="cov8" title="1">if dur &gt; int64(maxHashMS) &amp;&amp; maxHashMS &gt; 0 </span><span class="cov0" title="0">{
                return "", errors.Errorf("Hash function with %d rounds took %d ms (max %d). This is not as bad as being too fast, but may increase latency.", hashRounds, dur, maxHashMS)
        }</span>
        // Encode using base64URL
        <span class="cov8" title="1">encodedHash := stringEncode(pwd_hash)
        return encodedHash, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
