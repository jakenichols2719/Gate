
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">auth/pkg/authcode/authcode.go (100.0%)</option>
				
				<option value="file1">auth/pkg/authcred/access.go (75.0%)</option>
				
				<option value="file2">auth/pkg/authcred/database.go (68.3%)</option>
				
				<option value="file3">auth/pkg/authcred/hashing.go (78.6%)</option>
				
				<option value="file4">auth/pkg/authjwt/authjwt.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package authcode

import (
        "math/rand"
        "time"
)

type authorizationCode struct {
        Email   string
        Code    string
        Created time.Time
        Expires time.Time
}

var activeCodes map[string]*authorizationCode = make(map[string]*authorizationCode)

var letters = []rune("ABCDEFGHIJKLMNOPQRSTUVWXYZ")

/* Generates a ct-length authorization code using all-caps letters.
Input:
        ct int: Number of characters to generate
Output:
        string: string authorization code
*/
func genCode(ct int) string <span class="cov8" title="1">{
        seq := make([]rune, ct)
        for i := range seq </span><span class="cov8" title="1">{
                seq[i] = letters[rand.Intn(len(letters))]
        }</span>
        <span class="cov8" title="1">return string(seq)</span>
}

/* Generates a new authorization code, and stores it in memory for checking later.
Input:
        email string: Output code will be attached to this email. See authmail for how mail is sent.
Output:
        string: string authorization code.
*/
func NewAuthCode(email string) string <span class="cov8" title="1">{
        now := time.Now()
        newCode := &amp;authorizationCode{
                Email:   email,
                Code:    genCode(6),
                Created: now,
                Expires: now.Add(time.Minute * 5),
        }
        activeCodes[email] = newCode
        return newCode.Code
}</span>

/* Validates a given authorization code against an email.
Input:
        email, code string: Both the email and code must match records.
Output:
        bool: Represents code validity. true if code correct and unexpired, false if email incorrect, code incorrect, or expired.
*/
func ValidateAuthCode(email, code string) bool <span class="cov8" title="1">{
        storedCode, ok := activeCodes[email]
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if storedCode.Code == code &amp;&amp; storedCode.Expires.After(time.Now()) </span><span class="cov8" title="1">{
                delete(activeCodes, email)
                return true
        }</span> else<span class="cov8" title="1"> {
                delete(activeCodes, email)
                return false
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package authcred

import (
        "fmt"

        "gorm.io/gorm"
)

var db *gorm.DB

func addUser(in *userEntry) error <span class="cov8" title="1">{
        if db == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("addUser failed; database not open")
        }</span>
        <span class="cov8" title="1">db.Create(in)
        return nil</span>
}

func updateUser(in *userEntry) error <span class="cov8" title="1">{
        if db == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("updateUser failed; database not open")
        }</span>
        <span class="cov8" title="1">db.Save(in)
        return nil</span>
}

func findUserByEmail(find string) (out userEntry, err error) <span class="cov8" title="1">{
        if db == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("findUser failed; database not open")
        }</span> else<span class="cov8" title="1"> {
                db.Where("email = ?", find).First(&amp;out)
        }</span>
        <span class="cov8" title="1">return</span>
}

func findUserByUsername(find string) (out userEntry, err error) <span class="cov8" title="1">{
        if db == nil </span><span class="cov0" title="0">{
                err = fmt.Errorf("findUser failed; database not open")
        }</span> else<span class="cov8" title="1"> {
                db.Where("Username = ?", find).First(&amp;out)
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package authcred

import (
        "encoding/json"
        "fmt"

        "github.com/pkg/errors"
        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

/* From config.go: DBConfig
Path string
*/

type UserCred struct {
        Email    string `json:"email"`
        Username string `json:"username"`
}

type UserPerm map[string]bool

type User struct {
        Credentials UserCred `json:"credentials"`
        Permissions UserPerm `json:"permissions"`
}

// userEntry: User representation of the database
type userEntry struct {
        ID           uint   `gorm:"autoIncrement,primaryKey"`
        Email        string `gorm:"email"`
        Username     string `gorm:"username"`
        PasswordHash string `gorm:"password"`
        Salt         string `gorm:"salt"`
        HashFunc     string `gorm:"hashfunc"`
        Permissions  string `gorm:"permissions"`
}

func (u userEntry) ToUser() User <span class="cov0" title="0">{
        outUser := User{
                Credentials: UserCred{
                        u.Email,
                        u.Username,
                },
                Permissions: make(UserPerm),
        }
        json.Unmarshal([]byte(u.Permissions), &amp;outUser.Permissions)
        return outUser
}</span>

// Open the database
func OpenDB(path string) error <span class="cov8" title="1">{
        var err error
        db, err = gorm.Open(sqlite.Open(path), &amp;gorm.Config{Logger: logger.Default.LogMode(logger.Silent)})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = db.AutoMigrate(&amp;userEntry{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func Entries() int <span class="cov0" title="0">{
        entries := make([]userEntry, 0)
        db.Find(&amp;entries)
        return len(entries)
}</span>

// Exported version of findUserByEmail; returns public User instead of userEntry
func FindUserByEmail(email string) (User, error) <span class="cov0" title="0">{
        uentry, err := findUserByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, err
        }</span>
        <span class="cov0" title="0">return uentry.ToUser(), nil</span>
}

// Register a user with credentials and permissions
// Returns error or nil
func RegisterUser(email, username, password string, permissions UserPerm) error <span class="cov8" title="1">{
        if user, _ := findUserByEmail(email); user.Email != "" </span><span class="cov8" title="1">{
                return errors.New("Email is already in use.")
        }</span>
        <span class="cov8" title="1">if user, _ := findUserByUsername(username); user.Username != "" </span><span class="cov0" title="0">{
                return errors.New("Username is already in use.")
        }</span>
        <span class="cov8" title="1">perm, err := json.Marshal(permissions)
        salt, err := genSalt()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">pwdHash, err := slowHash([]byte(password), salt, "sha512")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">entry := &amp;userEntry{
                Email:        email,
                Username:     username,
                PasswordHash: pwdHash,
                Salt:         stringEncode(salt),
                HashFunc:     "sha512",
                Permissions:  string(perm),
        }
        addUser(entry)
        return nil</span>
}

// Validate a user with credentials
// Returns success, user info, and error/nil
func ValidateUserCred(username, password string) (bool, *User, error) <span class="cov8" title="1">{
        // Find user. Fail out if non-eistent
        user, err := findUserByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, err
        }</span>
        <span class="cov8" title="1">if user.Username == "" </span><span class="cov8" title="1">{
                return false, nil, fmt.Errorf("User %s not found", username)
        }</span>
        // Check hashed password against input password.
        <span class="cov8" title="1">salt, _ := stringDecode(user.Salt)
        pwdHash, err := slowHash([]byte(password), salt, user.HashFunc)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil, err
        }</span>
        <span class="cov8" title="1">valid := username == user.Username &amp;&amp; pwdHash == user.PasswordHash
        if valid </span><span class="cov8" title="1">{
                outUser := &amp;User{
                        Credentials: UserCred{
                                user.Email,
                                user.Username,
                        },
                        Permissions: make(UserPerm),
                }
                json.Unmarshal([]byte(user.Permissions), &amp;outUser.Permissions)
                return true, outUser, nil
        }</span> else<span class="cov8" title="1"> {
                return false, &amp;User{}, fmt.Errorf("User validation failed")
        }</span>
}

// Change user password
// Returns success and error/nil
func ChangeUserPassword(username, password string, newPassword string) error <span class="cov8" title="1">{
        valid, _, err := ValidateUserCred(username, password)
        if !valid </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("User validation failed")
                }</span>
        }
        <span class="cov8" title="1">user, err := findUserByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // If the user didn't exist, validation would have failed
        <span class="cov8" title="1">salt, _ := genSalt()
        pwdHash, err := slowHash([]byte(newPassword), salt, user.HashFunc)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">user.PasswordHash = pwdHash
        user.Salt = stringEncode(salt)
        updateUser(&amp;user)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package authcred

import (
        "crypto/rand"
        "crypto/sha512"
        "encoding/base64"
        "hash"
        "time"

        "github.com/pkg/errors"
)

// stringEncode shorthands for base64.URLEncoding.EncodeToString
func stringEncode(b []byte) string <span class="cov8" title="1">{
        return base64.RawURLEncoding.EncodeToString(b)
}</span>

// stringDecode shorthands base64.URLEncoding.DecodeString
func stringDecode(s string) ([]byte, error) <span class="cov8" title="1">{
        return base64.RawURLEncoding.DecodeString(s)
}</span>

// genSalt returns a 64-bit random byte string
func genSalt() ([]byte, error) <span class="cov8" title="1">{
        salt := make([]byte, 64)
        _, err := rand.Read(salt[:])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return salt, nil</span>
}

const hashRounds int = 65536
const minHashMS int = 20
const maxHashMS int = 0

var hfs map[string]func() hash.Hash = map[string]func() hash.Hash{
        "sha512": sha512.New,
}

// VERY SLOWLY hash pwd using a named hashFunc supported by auth.database, see hfs above
// Returns hash, salt, error (if occurs)
// DO NOT call any other hash function.
func slowHash(pwd, salt []byte, hashFunc string) (string, error) <span class="cov8" title="1">{
        // Get hash func. Return error if not supported
        f, ok := hfs[hashFunc]
        if !ok </span><span class="cov0" title="0">{
                return "", errors.Errorf("Hash function %s not supported", hashFunc)
        }</span>
        <span class="cov8" title="1">hf := f()
        pwd_full := append(pwd, salt...)
        pwd_hash := make([]byte, base64.URLEncoding.EncodedLen(hf.Size()))
        // Initial hash into pwd_hash
        if _, err := hf.Write(pwd_full); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span> else<span class="cov8" title="1"> {
                pwd_hash = hf.Sum(nil)
        }</span>
        // Repeatedly hash for hashRounds. Track time to complete.
        <span class="cov8" title="1">start := time.Now()
        for i := 0; i &lt; hashRounds; i++ </span><span class="cov8" title="1">{
                if _, err := hf.Write(pwd_hash); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span> else<span class="cov8" title="1"> {
                        pwd_hash = hf.Sum(nil)
                }</span>
        }
        <span class="cov8" title="1">dur := time.Now().Sub(start).Milliseconds()
        if dur &lt; int64(minHashMS) </span><span class="cov0" title="0">{
                return "", errors.Errorf("Hash function with %d rounds took %d ms (min %d). You should increase the number of rounds.", hashRounds, dur, minHashMS)
        }</span>
        <span class="cov8" title="1">if dur &gt; int64(maxHashMS) &amp;&amp; maxHashMS &gt; 0 </span><span class="cov0" title="0">{
                return "", errors.Errorf("Hash function with %d rounds took %d ms (max %d). This is not as bad as being too fast, but may increase latency.", hashRounds, dur, maxHashMS)
        }</span>
        // Encode using base64URL
        <span class="cov8" title="1">encodedHash := stringEncode(pwd_hash)
        return encodedHash, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package authjwt

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "strings"
        "time"
)

// JWTHeader: `auth` treats these as constants.
type JWTHeader struct {
        Algorithm string `json:"alg"`
        Type      string `json:"typ"`
}

// JWTBody: Token claims. All are registered except access, which is private.
type JWTBody struct {
        Issuer  string          `json:"iss"`
        ForUser string          `json:"sub"`
        Access  map[string]bool `json:"access"`
        Created int64           `json:"iat"`
        Expires int64           `json:"exp"`
}

// JSON Web Token structure combining the above.
type JSONWebToken struct {
        Header JWTHeader
        Body   JWTBody
}

// Create a new JWT based on a user email and access tag
func NewJWT(user string, access map[string]bool, expiry time.Duration) *JSONWebToken <span class="cov8" title="1">{
        return &amp;JSONWebToken{
                JWTHeader{
                        Algorithm: "sha256",
                        Type:      "jwt",
                },
                JWTBody{
                        Issuer:  "auth",
                        ForUser: user,
                        Access:  access,
                        Created: time.Now().Unix(),
                        Expires: time.Now().Add(1 * time.Hour).Unix(),
                },
        }
}</span>

// Export a JSONWebToken using a given secret
func Export(t *JSONWebToken, secret []byte) string <span class="cov8" title="1">{
        h := hmac.New(sha256.New, secret)
        // Marshal and encode the JWT header/body separately
        head, _ := json.Marshal(t.Header)
        headStr := base64.RawURLEncoding.EncodeToString(head)
        body, _ := json.Marshal(t.Body)
        bodyStr := base64.RawURLEncoding.EncodeToString(body)
        // Write head.body to the hashing algorithm
        h.Write([]byte(
                headStr + "." + bodyStr,
        ))
        // Get the signature from the hash
        signature := base64.RawURLEncoding.EncodeToString(h.Sum(nil))
        // Concatenate head.body.signature
        return headStr + "." + bodyStr + "." + signature
}</span>

// Verify that a token string is unaltered, unexpired, and signed with the given secret
func Verify(token string, secret []byte) (*JSONWebToken, bool, error) <span class="cov8" title="1">{
        items := strings.Split(token, ".")
        // Unmarshal and decode the JWT
        jwt := &amp;JSONWebToken{}
        head, err := base64.RawURLEncoding.DecodeString(items[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal([]byte(head), &amp;(jwt.Header))
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">body, err := base64.RawURLEncoding.DecodeString(items[1])
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal([]byte(body), &amp;(jwt.Body))
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>
        // Re-export the resulting jwt; should result in the exact same output
        <span class="cov8" title="1">expected := Export(jwt, secret)
        // Return verification eval result and new token
        expired := jwt.Body.Expires &lt; time.Now().Unix()
        return jwt, token == expected &amp;&amp; !expired, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
