
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>authcode: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">auth/pkg/authcode/authcode.go (100.0%)</option>
				
				<option value="file1">auth/pkg/authcred/access.go (100.0%)</option>
				
				<option value="file2">auth/pkg/authcred/authcred.go (82.4%)</option>
				
				<option value="file3">auth/pkg/authcred/hashing.go (82.6%)</option>
				
				<option value="file4">auth/pkg/authjwt/authjwt.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package authcode implements short-term code authentication.
//
// Generally speaking, authcode should be used in tandem with a separate package capable of remote communication with users.
// auth provides [pkg/authmail] for this purpose. A regular control flow with authcode may look like:
//   email := getUserEmailSomehow()
//   code := authcode.NewAuthCode(email)
//   sendEmailToUserSomehow(email, code)
//   ...
//   recEmail, recCode := receiveInputFromUserSomehow()
//   valid := authcode.ValidateAuthCode(recEmail, recCode)
// authcode does not currently protect against abandoned codes, so there's a risk of filling up memory.
package authcode

import (
        "math/rand"
        "time"
)

// An authorizationCode stores the email and code needed to validate, in addition to an expiration time.
type authorizationCode struct {
        Email   string
        Code    string
        Created time.Time
        Expires time.Time
}

// activeCodes maps emails to their respective codes.
var activeCodes map[string]*authorizationCode = make(map[string]*authorizationCode)

// letters contains a list of valid runes used in authorization codes.
var letters = []rune("ABCDEFGHIJKLMNOPQRSTUVWXYZ")

// Generates a ct-length authorization code using all-caps letters.
//
// Input:
//   - ct int: Number of characters to generate
// Output:
//   - string: string authorization code
func genCode(ct int) string <span class="cov8" title="1">{
        seq := make([]rune, ct)
        for i := range seq </span><span class="cov8" title="1">{
                seq[i] = letters[rand.Intn(len(letters))]
        }</span>
        <span class="cov8" title="1">return string(seq)</span>
}

// Generates a new authorization code, and stores it in memory for checking later.
//
// Input:
//   - email string: Output code will be attached to this email. See authmail for how mail is sent.
// Output:
//   - string: string authorization code.
func NewAuthCode(email string) string <span class="cov8" title="1">{
        now := time.Now()
        newCode := &amp;authorizationCode{
                Email:   email,
                Code:    genCode(6),
                Created: now,
                Expires: now.Add(time.Minute * 5),
        }
        activeCodes[email] = newCode
        return newCode.Code
}</span>

// Validates a given authorization code against an email.
//
// Input:
//   - email, code string: Both the email and code must match records.
// Output:
//   - bool: Represents code validity. true if code correct and unexpired, false if email incorrect, code incorrect, or expired.
func ValidateAuthCode(email, code string) bool <span class="cov8" title="1">{
        storedCode, ok := activeCodes[email]
        if !ok </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if storedCode.Code == code &amp;&amp; storedCode.Expires.After(time.Now()) </span><span class="cov8" title="1">{
                delete(activeCodes, email)
                return true
        }</span> else<span class="cov8" title="1"> {
                delete(activeCodes, email)
                return false
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package authcred

import (
        "fmt"

        "gorm.io/gorm"
)

var db *gorm.DB

// Add a userEntry to the database.
//
// Input:
//   - in *userEntry: User entry to add.
// Output:
//   - error: Returned if the database is closed.
func addUser(in *userEntry) error <span class="cov8" title="1">{
        if db == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("addUser failed; database not open")
        }</span>
        <span class="cov8" title="1">db.Create(in)
        return nil</span>
}

// Update a userEntry in the database.
//
// Input:
//   - in *userEntry: User entry to alter. GORM manages this operation using primary key, which is the
//   int id of the entry. Highly suggest you don't try changing that.
// Output:
//   - error: Returned if the database is closed.
func updateUser(in *userEntry) error <span class="cov8" title="1">{
        if db == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("updateUser failed; database not open")
        }</span>
        <span class="cov8" title="1">db.Save(in)
        return nil</span>
}

// Find a userEntry in the database by its email.
//
// Input:
//   - find string: Email to find.
// Output:
//   - out userEntry: The resulting userEntry.
//   - err error: Returned if the database is closed.
func findUserEntryByEmail(find string) (out userEntry, err error) <span class="cov8" title="1">{
        if db == nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("findUser failed; database not open")
        }</span> else<span class="cov8" title="1"> {
                db.Where("email = ?", find).First(&amp;out)
        }</span>
        <span class="cov8" title="1">return</span>
}

// Find a userEntry in the database by its username.
//
// Input:
//   - find string: Username to find.
// Output:
//   - out userEntry: The resulting userEntry.
//   - err error: Returned if the database is closed.
func findUserEntryByUsername(find string) (out userEntry, err error) <span class="cov8" title="1">{
        if db == nil </span><span class="cov8" title="1">{
                err = fmt.Errorf("findUser failed; database not open")
        }</span> else<span class="cov8" title="1"> {
                db.Where("Username = ?", find).First(&amp;out)
        }</span>
        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package authcred handles the authentication of users using username-password pairs
// Each user is stored as a userEntry in a local database. The database columns are defined
// by the userEntry struct, so they appear as seen below:
//   +----+-------+----------+---------------+------+---------------+-------------+
//   | ID | Email | Username | Password Hash | Salt | Hash Function | Permissions |
//   +----+-------+----------+---------------+------+---------------+-------------+
// Two main authentication functions are provided in RegisterUser() and ValidateUserCred(),
// with supporting functions ChangeUserPassword() and ChangeUserPermissions() to alter the
// data of already-existing users in the database.
//
// authcred exports the User type, which contains the same data as userEntry with private data
// (password hash, salt, hash func, internal ID) removed. ValidateUserCred() returns one, so that
// when the authentication API is called, it returns back information about the user in a format
// that can easily pass back to the application servers or converted into a token without exposing
// important data.
package authcred

import (
        "encoding/json"
        "fmt"

        "github.com/pkg/errors"
        "gorm.io/driver/sqlite"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"
)

/* From config.go: DBConfig
Path string
*/

// A User contains *public* information about a user.
// authcred functions that return user info MUST return this.
type User struct {
        Email       string          `json:"email"`
        Username    string          `json:"username"`
        Permissions map[string]bool `json:"permissions"`
}

// Empty() checks if the calling User is the empty User.
// This means no email or username, and 0 permissions.
//
// Calling:
//   - u User: User to check.
// Output:
//   - bool: Is u the empty User?
func (u User) Empty() bool <span class="cov8" title="1">{
        return u.Email == "" &amp;&amp; u.Username == "" &amp;&amp; len(u.Permissions) == 0
}</span>

// A userEntry contains public *and private* information about a user.
// authcred functions that are exported MUST NOT return this.
type userEntry struct {
        ID           uint   `gorm:"autoIncrement,primaryKey"`
        Email        string `gorm:"email"`
        Username     string `gorm:"username"`
        PasswordHash string `gorm:"password"`
        Salt         string `gorm:"salt"`
        HashFunc     string `gorm:"hashfunc"`
        Permissions  string `gorm:"permissions"`
}

// Empty() checks if the calling userEntry is the empty userEntry.
//
// Calling:
//   - u userEntry: userEntry to check.
// Output:
//   - bool: Is u the empty userEntry?
func (u userEntry) Empty() bool <span class="cov8" title="1">{
        return u.ID == 0 &amp;&amp; u.Email == "" &amp;&amp; u.Username == "" &amp;&amp; u.PasswordHash == "" &amp;&amp; u.Salt == "" &amp;&amp; u.HashFunc == "" &amp;&amp; u.Permissions == ""
}</span>

// toUser converts the calling userEntry into a User.
//
// Calling:
//   - u userEntry: Data to convert. Notably, the zero userEntry converts to the zero User.
// Output:
//   - User: the resulting public User struct.
func (u userEntry) toUser() User <span class="cov8" title="1">{
        outUser := User{
                Email:       u.Email,
                Username:    u.Username,
                Permissions: make(map[string]bool),
        }
        json.Unmarshal([]byte(u.Permissions), &amp;outUser.Permissions)
        return outUser
}</span>

// Open the database.
// This MUST be called before any authcred operations take place, and if the path is changed,
// a different DB will be opened; this is configured under DB.Path in config.yml, and should probably not
// change unless you have a testing database to use.
// Only one database can be open at a time.
//
// Input:
//   - path string: Path to the database file
// Output:
//   - error: Output if the open fails, or if the userEntry struct changes in a way that prevents migrating the DB.
//   This most commonly occurs if the path does not exist; gorm can create a new file, but not directories.
func OpenDB(path string) error <span class="cov8" title="1">{
        var err error
        db, err = gorm.Open(sqlite.Open(path), &amp;gorm.Config{Logger: logger.Default.LogMode(logger.Silent)})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err = db.AutoMigrate(&amp;userEntry{})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Get the current number of entries in the database.
// It's not likely that this has significant use outside of noticing if the user is initializing a new database; to preserve
// security in this case, the user should be asked to create the first account as an admin account before opening to a network.
//
// Output:
//   - int: Number of entries in the current database
func Entries() int <span class="cov8" title="1">{
        entries := make([]userEntry, 0)
        db.Find(&amp;entries)
        return len(entries)
}</span>

// Exported version of findUserEntryByEmail; returns public User instead of userEntry.
//
// Input:
//   - email string: Email to find
// Output:
//   - User: User data, or empty user if not found.
func FindUserByEmail(email string) (User, error) <span class="cov8" title="1">{
        uentry, err := findUserEntryByEmail(email)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, err
        }</span>
        <span class="cov8" title="1">return uentry.toUser(), nil</span>
}

// Exported version of findUserEntryByUsername; returns public User instead of userEntry.
//
// Input:
//   - username string: Username to find
// Output:
//   - User: User data, or empty user if not found.
func FindUserByUsername(username string) (User, error) <span class="cov8" title="1">{
        uentry, err := findUserEntryByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return User{}, err
        }</span>
        <span class="cov8" title="1">return uentry.toUser(), nil</span>
}

// Register a user with the given credentials and permissions.
//
// Input:
//   - email, username string: User email/username pair. Both of these values MUST be unique.
//   - password string: User password. To avoid conflicts with integration, auth imposes no password restrictions; it is
//   expected that the application manage restrictions such as password length.
//   - permissions map[string]bool: User permissions. auth only takes advantage of the admin permission; all others are
//   application-defined.
// Output:
//   - error: Any errors that occur during the registration of a user, including: non-unique email/username, failure to generate
//   password salt, failure to hash password. If an error is returned, no change is made to the database.
func RegisterUser(email, username string, password string, permissions map[string]bool) error <span class="cov8" title="1">{
        if user, _ := findUserEntryByEmail(email); user.Email != "" </span><span class="cov8" title="1">{
                return errors.New("Email is already in use.")
        }</span>
        <span class="cov8" title="1">if user, _ := findUserEntryByUsername(username); user.Username != "" </span><span class="cov0" title="0">{
                return errors.New("Username is already in use.")
        }</span>
        <span class="cov8" title="1">perm, _ := json.Marshal(permissions)
        salt, err := genSalt()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">pwdHash, err := slowHash([]byte(password), salt, "sha512")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">entry := &amp;userEntry{
                Email:        email,
                Username:     username,
                PasswordHash: pwdHash,
                Salt:         stringEncode(salt),
                HashFunc:     "sha512",
                Permissions:  string(perm),
        }
        addUser(entry)
        return nil</span>
}

// Validate a user with username and password credentials.
//
// Input:
//   - username, password string: User credentials. The username will be used to find the userEntry, and then the password
//   will be hashed with that userEntry salt and hash function and compared to the userEntry password.
// Output:
//   - bool: Is user valid?
//   - User: Public user credentials.
//   - error: Any errors that occur during user validation, including: failure to find user, failure to hash password, failure to validate
//   user.
func ValidateUserCred(username, password string) (bool, User, error) <span class="cov8" title="1">{
        // Find user. Fail out if non-eistent
        user, err := findUserEntryByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return false, User{}, err
        }</span>
        <span class="cov8" title="1">if user.Username == "" </span><span class="cov8" title="1">{
                return false, User{}, fmt.Errorf("User %s not found", username)
        }</span>
        // Check hashed password against input password.
        <span class="cov8" title="1">salt, _ := stringDecode(user.Salt)
        pwdHash, err := slowHash([]byte(password), salt, user.HashFunc)
        if err != nil </span><span class="cov0" title="0">{
                return false, User{}, err
        }</span>
        <span class="cov8" title="1">valid := username == user.Username &amp;&amp; pwdHash == user.PasswordHash
        if valid </span><span class="cov8" title="1">{
                outUser := User{
                        Email:       user.Email,
                        Username:    user.Username,
                        Permissions: make(map[string]bool),
                }
                json.Unmarshal([]byte(user.Permissions), &amp;outUser.Permissions)
                return true, outUser, nil
        }</span> else<span class="cov8" title="1"> {
                return false, User{}, fmt.Errorf("User validation failed")
        }</span>
}

// Validate a user's current credentials, then change their password if they could be validated.
//
// Input:
//   - username, password string: User credentials. See ValidateUserCred.
//   - newPassword string: New password to set IF the above credentials can be validated.
// Output:
//   - error: Any error that occurs when changing user password, including: failure to validate,
//   user doesn't exist, failure to hash password
func ChangeUserPassword(username, password string, newPassword string) error <span class="cov8" title="1">{
        valid, _, err := ValidateUserCred(username, password)
        if !valid </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span> else<span class="cov0" title="0"> {
                        return fmt.Errorf("User validation failed")
                }</span>
        }
        // If the user didn't exist, validation would have failed
        <span class="cov8" title="1">user, err := findUserEntryByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">salt, err := genSalt()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">pwdHash, err := slowHash([]byte(newPassword), salt, user.HashFunc)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">user.PasswordHash = pwdHash
        user.Salt = stringEncode(salt)
        updateUser(&amp;user)
        return nil</span>
}

// Change user permissions for a given user.
// This action is generally initiated by an admin or the application server, and not a user; as a result,
// no password is required for the user.
//
// Input:
//   - username string: Username to alter.
//   - newPermissions map[string]bool: Full list of new permissions. Overwrites any permissions with the same name.
// Output:
//   - error: Any error that occurs while changing permissions, including: user does not exist, failure to marshal
//   permissions
func ChangeUserPermissions(username string, newPermissions map[string]bool) error <span class="cov8" title="1">{
        // Get userEntry. We need the entry ID to update the DB
        entry, err := findUserEntryByUsername(username)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Get the corresponding User. This unmarshals the permissions string in entry so we can change permissions without a full overwrite.
        <span class="cov8" title="1">user := entry.toUser()
        // Write every key-value pair from newPermissions to old permissions.
        for name, value := range newPermissions </span><span class="cov8" title="1">{
                // It's possible user had no permissions before.
                if user.Permissions == nil </span><span class="cov8" title="1">{
                        user.Permissions = make(map[string]bool)
                }</span>
                <span class="cov8" title="1">user.Permissions[name] = value</span>
        }
        // Re-stringify permissions and update the entry in the database.
        <span class="cov8" title="1">bytePerms, err := json.Marshal(user.Permissions)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">entry.Permissions = string(bytePerms)
        updateUser(&amp;entry)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package authcred

import (
        "crypto/rand"
        "crypto/sha512"
        "encoding/base64"
        "hash"
        "time"

        "github.com/pkg/errors"
)

// stringEncode is shorthand for base64.URLEncoding.EncodeToString().
var stringEncode func([]byte) string = base64.RawURLEncoding.EncodeToString

// stringDecode is shorthand for base64.URLEncoding.DecodeString().
var stringDecode func(string) ([]byte, error) = base64.RawURLEncoding.DecodeString

// genSalt returns a 64-bit random byte string
func genSalt() ([]byte, error) <span class="cov8" title="1">{
        salt := make([]byte, 64)
        bytesRead := 0
        // Make 3 attempts to generate salt value.
        for attempts := 0; attempts &lt; 3 &amp;&amp; bytesRead &lt; 64; attempts++ </span><span class="cov8" title="1">{
                attBytesRead, err := rand.Read(salt[bytesRead:])
                bytesRead += attBytesRead
                // We do need to check the error here, but it may not be fatal (EOF). This behavior could be improved.
                // It is usually OS-related and asks the user to wait for the syscall to be available for random generation,
                // so if an error occurs and we didn't finish reading to salt, we'll wait for 100ms
                if err != nil &amp;&amp; bytesRead &lt; 64 </span><span class="cov0" title="0">{
                        time.Sleep(time.Millisecond * 100)
                }</span>
        }
        <span class="cov8" title="1">return salt, nil</span>
}

const hashRounds int = 131072 // 2^17
const minHashMS int = 20

// hfs is a map of string hash function names to a Go Hash object creator.
// See slowHash for an example of usage.
var hfs map[string]func() hash.Hash = map[string]func() hash.Hash{
        "sha512": sha512.New,
}

// Hashes a byte string VERY SLOWLY with a specific hashfunc supported by hfs.
// Any private value used in auth MUST be hashed through slowHash.
//
// Input:
//   - pwd, salt byte: Password (or other string) to hash, and the salt to hash it with.
//   - hashFunc string: Hash function to use. Must be a key in hfs.
// Output:
//   - string: Output hashed value
//   - error: Any error that occurs, including: unsupported hash function
func slowHash(pwd, salt []byte, hashFunc string) (string, error) <span class="cov8" title="1">{
        // Get hash func. Return error if not supported
        f, ok := hfs[hashFunc]
        if !ok </span><span class="cov0" title="0">{
                return "", errors.Errorf("Hash function %s not supported", hashFunc)
        }</span>
        <span class="cov8" title="1">hf := f()
        pwd_full := append(pwd, salt...)
        pwd_hash := make([]byte, base64.URLEncoding.EncodedLen(hf.Size()))
        // Initial hash into pwd_hash
        if _, err := hf.Write(pwd_full); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span> else<span class="cov8" title="1"> {
                pwd_hash = hf.Sum(nil)
        }</span>
        // Repeatedly hash for 2^17 rounds.
        <span class="cov8" title="1">for i := 0; i &lt; 131072; i++ </span><span class="cov8" title="1">{
                if _, err := hf.Write(pwd_hash); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span> else<span class="cov8" title="1"> {
                        pwd_hash = hf.Sum(nil)
                }</span>
        }
        // Encode using base64URL
        <span class="cov8" title="1">encodedHash := stringEncode(pwd_hash)
        return encodedHash, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package authjwt

import (
        "crypto/hmac"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "strings"
        "time"
)

// JWTHeader: `auth` treats these as constants.
type JWTHeader struct {
        Algorithm string `json:"alg"`
        Type      string `json:"typ"`
}

// JWTBody: Token claims. All are registered except access, which is private.
type JWTBody struct {
        Issuer  string          `json:"iss"`
        ForUser string          `json:"sub"`
        Access  map[string]bool `json:"access"`
        Created int64           `json:"iat"`
        Expires int64           `json:"exp"`
}

// JSON Web Token structure combining the above.
type JSONWebToken struct {
        Header JWTHeader
        Body   JWTBody
}

// Create a new JWT based on a user email and access tag
func NewJWT(user string, access map[string]bool, expiry time.Duration) *JSONWebToken <span class="cov8" title="1">{
        return &amp;JSONWebToken{
                JWTHeader{
                        Algorithm: "sha256",
                        Type:      "jwt",
                },
                JWTBody{
                        Issuer:  "auth",
                        ForUser: user,
                        Access:  access,
                        Created: time.Now().Unix(),
                        Expires: time.Now().Add(1 * time.Hour).Unix(),
                },
        }
}</span>

// Export a JSONWebToken using a given secret
func Export(t *JSONWebToken, secret []byte) string <span class="cov8" title="1">{
        h := hmac.New(sha256.New, secret)
        // Marshal and encode the JWT header/body separately
        head, _ := json.Marshal(t.Header)
        headStr := base64.RawURLEncoding.EncodeToString(head)
        body, _ := json.Marshal(t.Body)
        bodyStr := base64.RawURLEncoding.EncodeToString(body)
        // Write head.body to the hashing algorithm
        h.Write([]byte(
                headStr + "." + bodyStr,
        ))
        // Get the signature from the hash
        signature := base64.RawURLEncoding.EncodeToString(h.Sum(nil))
        // Concatenate head.body.signature
        return headStr + "." + bodyStr + "." + signature
}</span>

// Verify that a token string is unaltered, unexpired, and signed with the given secret
func Verify(token string, secret []byte) (*JSONWebToken, bool, error) <span class="cov8" title="1">{
        items := strings.Split(token, ".")
        // Unmarshal and decode the JWT
        jwt := &amp;JSONWebToken{}
        head, err := base64.RawURLEncoding.DecodeString(items[0])
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal([]byte(head), &amp;(jwt.Header))
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">body, err := base64.RawURLEncoding.DecodeString(items[1])
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">err = json.Unmarshal([]byte(body), &amp;(jwt.Body))
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>
        // Re-export the resulting jwt; should result in the exact same output
        <span class="cov8" title="1">expected := Export(jwt, secret)
        // Return verification eval result and new token
        expired := jwt.Body.Expires &lt; time.Now().Unix()
        return jwt, token == expected &amp;&amp; !expired, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
